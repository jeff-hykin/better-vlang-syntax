- source: module
  scopesBegin:
    - meta.module
  scopes:
    - keyword.module
- source: os
  scopes:
    - entity.name.module
  scopesEnd:
    - meta.module
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' mkdir'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: if
  scopes:
    - keyword.control
- source: ' path '
- source: '=='
  scopes:
    - keyword.operator.relation
- source: ' '''
- source: .
  scopes:
    - punctuation.accessor
- source: ''' '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: 'true'
  scopes:
    - constant.language
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: $fs.mkdirSync(path.valueOf())
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: 'true'
  scopes:
    - constant.language
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: $else
  scopes:
    - keyword.control
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: 'false'
  scopes:
    - constant.language
- source: '}'
  scopesBegin:
    - punctuation.definition.bracket.curly.end
- source: '}'
  scopesEnd:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' is_dir'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: 'false'
  scopes:
    - constant.language
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: 'res.val = $fs.existsSync(path,str) && $fs.lstatSync(path.str).isDirectory()'
  scopesEnd:
    - markup.bold
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' is_link'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: 'false'
  scopes:
    - constant.language
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: >-
    res.val = $fs.existsSync(path.str) &&
    $fs.lstatSync(path.str).isSymbolicLink()
  scopesEnd:
    - markup.bold
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' exists'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: 'false'
  scopes:
    - constant.language
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: res.val = $fs.existsSync(path.str)
  scopesEnd:
    - markup.bold
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' ls'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: '['
  scopes:
    - punctuation.definition.bracket.square.begin
- source: ']'
  scopes:
    - punctuation.definition.bracket.square.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: if
  scopes:
    - keyword.control
- source: '!'
  scopes:
    - keyword.operator.logical
- source: is_dir
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: path
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: ' error'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: '''ls'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: ': cannot open dir $dir'''
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: "\tresult"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: '['
  scopes:
    - punctuation.definition.bracket.square.begin
- source: ']'
  scopes:
    - punctuation.definition.bracket.square.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: let i = 0
- source: "\t\t#"
- source: >-
    $fs.readdirSync(path.str).forEach((path) => result.arr[i++] = new
    string(path))
  scopesEnd:
    - markup.bold
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: return
  scopes:
    - keyword.control
- source: ' result'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' get_raw_line'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: ' '''''
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' executable'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: ' '''''
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' is_executable'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\teprintln"
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: '''TODO: There'
- source: is
  scopes:
    - keyword.is
- source: 'no'
  scopes:
    - entity.name.alias
- source: ' isExecutable on fs'
- source: .
  scopes:
    - punctuation.accessor
- source: stats'
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: return
  scopes:
    - keyword.control
- source: 'false'
  scopes:
    - constant.language
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' rmdir'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\terr"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: 'try {'
- source: "\t\t#"
- source: $fs.rmdirSync(path.str)
- source: "\t\t#"
- source: return;
- source: "\t\t#"
- source: '} catch (e) {'
- source: "\t\t#"
- source: 'err.str = ''Failed to remove "'' + path.str + ''": '' + e.toString()'
- source: "\t\t#"
- source: '}'
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' error'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: err
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '}'
  scopesBegin:
    - punctuation.definition.bracket.curly.end
- source: '}'
  scopesEnd:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' rm'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\terr"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: 'try {'
- source: "\t\t#"
- source: $fs.rmSync(path.str)
- source: "\t\t#"
- source: return;
- source: "\t\t#"
- source: '} catch (e) {'
- source: "\t\t#"
- source: 'err.str = ''Failed to remove "'' + path.str + ''": '' + e.toString()'
- source: "\t\t#"
- source: '}'
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' error'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: err
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '}'
  scopesBegin:
    - punctuation.definition.bracket.curly.end
- source: '}'
  scopesEnd:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' cp'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'src '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: ','
  scopes:
    - punctuation.separator.comma
- source: ' dst '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\terr"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: 'try {'
- source: "\t\t#"
- source: '$fs.cpSync(src.str,dst.str);'
- source: "\t\t#"
- source: return;
- source: "\t\t#"
- source: '} catch (e) {'
- source: "\t\t#"
- source: >-
    err.str = 'failed to copy ' + src.str + ' to ' + dst.str + ': ' +
    e.toString();
- source: "\t\t#"
- source: '}'
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' error'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: err
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '}'
  scopesBegin:
    - punctuation.definition.bracket.curly.end
- source: '}'
  scopesEnd:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' read_file'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 's '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: mut
  scopes:
    - storage.modifier
- source: ' err'
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\terr"
- source: '='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: err
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\t#"
  scopesBegin:
    - markup.bold
- source: 'try {'
- source: "\t#"
- source: res.str = $fs.readFileSync(s.str).toString()
- source: "\t#"
- source: '} catch (e) {'
- source: "\t#"
- source: 'err.str = ''Failed to read file: '' + e.toString()'
- source: "\t#"
- source: return error(err)
- source: "\t#"
- source: '}'
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' getwd'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: ''''''
- source: "\t#"
  scopesBegin:
    - markup.bold
- source: res.str = $process.cwd()
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' getuid'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: int
  scopes:
    - storage.type.numeric
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: '0'
  scopes:
    - constant.numeric.integer
- source: "\t#"
  scopesBegin:
    - markup.bold
- source: if (process.getuid) res.val = process.getuid();
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' execvp'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'cmd '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: ','
  scopes:
    - punctuation.separator.comma
- source: ' args '
- source: '['
  scopes:
    - punctuation.definition.bracket.square.begin
- source: ']'
  scopes:
    - punctuation.definition.bracket.square.end
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '?'
  scopes:
    - keyword.operator.optional
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\tpanic"
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: '''os'
- source: .
  scopes:
    - punctuation.accessor
- source: execvp
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: is
  scopes:
    - keyword.is
- source: not
  scopes:
    - entity.name.alias
- source: ' available on JS backend'''
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' stdin_resume'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t#"
  scopesBegin:
    - markup.bold
- source: $process.stdin.resume();
  scopesEnd:
    - markup.bold
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: pub
  scopes:
    - storage.modifier
- source: fn
  scopes:
    - keyword.fn
- source: ' is_readable'
- source: (
  scopes:
    - punctuation.definition.bracket.round.begin
- source: 'path '
- source: string
  scopes:
    - meta.expr.bool.cast
    - storage.type.string
- source: )
  scopes:
    - punctuation.definition.bracket.round.end
- source: bool
  scopes:
    - meta.expr.bool.cast
    - storage.type.bool
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: $if
  scopes:
    - keyword.control
- source: ' js_node '
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: "\t\tres"
- source: ':='
  scopes:
    - meta.definition.variable
    - keyword.operator.assignment
- source: 'false'
  scopes:
    - constant.language
- source: "\t\t#"
  scopesBegin:
    - markup.bold
- source: >-
    try { res.val = $fs.accessSync(path.str,$fs.constants.R_OK); } catch {
    res.val = false; }
  scopesEnd:
    - markup.bold
- source: return
  scopes:
    - keyword.control
- source: ' res'
- source: '}'
  scopes:
    - punctuation.definition.bracket.curly.end
- source: $else
  scopes:
    - keyword.control
- source: '{'
  scopes:
    - punctuation.definition.bracket.curly.begin
- source: return
  scopes:
    - keyword.control
- source: 'false'
  scopes:
    - constant.language
- source: '}'
  scopesBegin:
    - punctuation.definition.bracket.curly.end
- source: '}'
